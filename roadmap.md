- [] 多线程环境下使用Future结合Executor框架实现阻塞获取爬取结果。 

## 失败思路

直接使用executor service 的 submit方法返回一个future，层层传递由上层汇总。

失败原因：每一层的传递future导致线程依赖，当任务数量多于线程池内的线程数量时，出现层层等待，但是下层没有线程可用，导致死锁。


## 新实现思路（暂定）：

自定义实现Future接口，重写get等阻塞获取方法，当调用时阻塞线程，通过任务id判定完成条件：

* 下载任务队列是否为空
* 所有下载器是否下载完成
* 所有分析器是否分析完成

有任一条件未满足则该任务未完成。


具体实现有两种思路：

1. 循环判定，但是这种方式实现不是很好，没有明显优势
2. 建立整套事件机制，任务发送模块能够得到其他模块的事件通知，使用concurrent包中的Condition类来实现阻塞以及解除阻塞.

目前计划按照第二种思路执行。


## 任务列表

- [ ] 建立可扩展为分布式的事件模块
- [ ] 分别为下载模块，分析模块，任务调度器加入事件支持
    - [ ] 下载模块事件：下载开始（taskId），下载结束(taskId),下载发生错误(taskId,error)
    - [ ] 分析模块事件：分析开始(taskId) ，分析结束(taskId),产生url(taskId,url),抓取到结果(taskId)
    - [ ] 任务调度器事件： 新增url(taskId,url),pop url(taskId,url) 
- [ ] 发送端实现事件监听，建立一个统一的事件处理模块，为每个任务维护一个计数器，当计数器归零，回调发送阻塞方法解除阻塞，返回结果。
